# Решения [adventofcode.com 2024](https://adventofcode.com/2024/)

1. Нужно сложить два массива цифр, потом использовать Counter, перемножить и снова сложить. Задача не сложная, но всегда 
можно поиграться с numpy и попытаться решить без Counter
2. Проверить массив на соответствие критериям. Увы во второй части не смог придумать ничего кроме перебора разных 
вариантов, хотя и обошелся без сортировок.
3. Первая часть простое регулярное выражение, во второй части нужно добавить немного логики, хотя наверно можно было бы
предварительно вырезать все ненужные части из строки.
4. В целом всё понятно, но во второй части очень неочевидное условие о том, что не засчитываются надписи 
которые "лежат на боку". Например, такой вариант не подходит:
```
  M.S
  .A.
  M.S
```
5. Показалось сложная задача для пятого дня. Первое, что пришло в голову отсортировать цифры в какой-то
последовательности и сделать связанный список чтобы потом сравнивать инструкции с ним. Но данные нельзя представить в 
виде списка, а это граф. Вторая часть задачи логично решается если сразу использовать networkx #topological_sort
6. Ходим и поворачиваем. Чем то напомнила [задачу про паром](https://adventofcode.com/2020/day/12). Вторая часть посложнее, ничего кроме перебора всех вариантов 
придумать не смог.
7. Динамическое программирование. Хотя наверно можно решить перебором всех вариантов операторов, скорее всего это будет дольше.
8. Очень скучная задача где нужно просто много считать.
9. Простенькая первая часть, чуть сложнее вторая. Не получилось сделать читаемый код во второй части.
10. Простая задачка на графы. В первой части нужно найти и сложить просто пути, во второй части нужно найти все возможные пути.
11. Начались задачи на оптимизацию, сложность задачи O(2^n), нужно придумать как кэшировать промежуточные результаты.
12. [Компоненты связанности графа](https://ru.wikipedia.org/wiki/Компонента_связности_графа)
13. Пятница 13. Пока самая интересная задача. На ум приходят [Линейные диофантовы уравнения](https://foxford.ru/wiki/matematika/lineynye-diofantovy-uravneniya-s-dvumya-neizvestnymi).
Однако не преуспев в школьной алгебре решил используя [Z3](https://en.wikipedia.org/wiki/Z3_Theorem_Prover).

PS: Не reddit нашлось красивое алгебраическое решение.
```python
def mincost(ax, ay, bx, by, px, py):
    b, brem = divmod(ay * px - ax * py, ay * bx - ax * by)
    a, arem = divmod(px - b * bx, ax)
    return 0 if arem or brem else a * 3 + b
```
14. Простая первая часть, в вот вторая это ужасна. Условия удалось понять только прочитав тред на редите. Мне повезло 
мое решение это просто шаг с минимальным score factor. Почему это работает, я объяснения не нашел. Другие варианты решения:
- искать ряд или столбик из N роботов
- искать шаг на котором у роботов максимальное количество соседей
- придумать коэффициент, который зависит от "разбросанности" роб тов по полю

15. Играем в [сокобан](https://ru.wikipedia.org/wiki/Sokoban)

16. Поиск кратчайшего пути в графе. Однако основная сложность как представить входные данные в виде графа.

17. Лютейший реверс-инженеринг. Простая первая часть, в которой нужно написать эмулятор компьютера, выполняющего некую программу.
Абсолютно непонятная вторая часть. Кажется, что ее можно забрутфорсить, но судя по комментам на редите это сложно даже на GPU.

Оказалось нужно понять, что код представляет собой цикл, который работает пока А > 0. На каждой итерации от значения А
отсекаются 3 младших бита.

```
11000110100001110001110100 
11000110100001110001110
11000110100001110001
...
11000
11
0
```

При этом на выходе могут быть цифры от 1 до 7. Значит можно найти ответ перебирав всего 8^длина программы значений.

Пока самая сложная задача.

18. Удивительно простая задача для 18 дня, опять поиски путей в графе. Подвох в том, как составлено задание. В первой части не
нужно использовать все данные для расчета, а только часть. Скорее задача на внимательность прочтения задания.

19. Динамическое программирование, кэш. 